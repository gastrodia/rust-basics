// 变量的解构
fn main() {
    let (a, mut b): (i32, i32) = (1, 2);
    println!("b的初始值: {}", b);
    b = 3;
    assert_eq!(a, 1);
    assert_eq!(b, 3);
    println!("a:{}", a);
    println!("b:{}", b);

    /*

        assert_eq! 是 Rust 的一个宏，用于断言两个表达式是否相等
    如果相等，则继续执行；如果不相等，则程序会 panic
    主要用于测试和调试代码
    返回值是 ()，即 Rust 中的空元组（unit type）
         */

    // print! - 打印文本但不换行
    // println! - 打印文本并换行
    /*
    为什么要加 !
    在 Rust 中，带 ! 的表示这是一个宏（macro），而不是普通函数。
    主要原因是：
    宏更灵活 - 宏可以接受可变数量的参数，而普通函数必须有固定的参数数量
    编译时展开 - 宏在编译时被展开成实际的代码，可以生成多行代码
    格式化字符串检查 - 编译器可以在编译时检查格式化字符串的正确性
    比如这些都是合法的宏调用：
    如果 println 是普通函数，就无法实现这种灵活的参数处理。这就是为什么 Rust 选择使用宏来实现打印功能。
     */
    print!("不会换行");
    print!("不会换行");
    println!("不会换行");
    print!("被上面的println换行了");
}
